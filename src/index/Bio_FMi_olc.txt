#include "Bio_FMi.h"

namespace bio_fmi
{

    Bio_FMi::Bio_FMi(std::filesystem::path eds_file, unsigned context_length)
        : context_length_(context_length), eds_file_(eds_file)
    {
        //  create folder for the index
        std::string filename = eds_file.filename();
        std::string ext = eds_file.extension().c_str();
        index_bed_ = eds_file;
        index_bed_ = index_bed_.replace_extension(ext + ".index");
        std::cout << "Index destination on " << index_bed_ << std::endl;
        if (!std::filesystem::exists(index_bed_))
            std::filesystem::create_directories(index_bed_);
        index_bed_.append(filename);

        //  metadata files - for reference string and the string of changes
        reference_filepath_ = index_bed_;
        reference_filepath_.replace_extension(ext + ".metadata.ref");

        changes_filepath_ = index_bed_;
        changes_filepath_.replace_extension(ext + ".metadata.chan");
    }

    Bio_FMi::Bio_FMi(std::filesystem::path index_folder)
    {
        //  find context length in folder name
        std::string filename = index_folder.filename().replace_extension("");
        index_bed_ = index_folder / filename;

        std::cout << "Index will be loaded from " << index_bed_ << std::endl;

        // Extract the number from the filename
        bool open = false;
        std::string number_str;
        for (size_t i = 0; i < filename.size(); i++)
        {
            // Check if the component matches the pattern <name>.<number>.eds.index
            if (open)
                number_str.push_back(filename[i]);
            if (filename[i] == '.' && open)
                break;
            if (filename[i] == '.' && !open)
                open = true;
        }

        // Convert the extracted string to an integer
        try
        {
            context_length_ = std::stoi(number_str);

            // Print the extracted number
        }
        catch (const std::exception &e)
        {
            std::cerr << "Error: context length was not found. Please setup explicitly: " << std::endl;
            std::cin >> context_length_;
        }

        load();
        print();
    }

    Bio_FMi::~Bio_FMi()
    {
    }

    int Bio_FMi::parse_eds()
    {
        //  open file
        std::ifstream in(eds_file_);
        if (!in.is_open())
        {
            std::cerr << "Error: Unable to open file " << eds_file_ << std::endl;
            return -1;
        }

        std::ofstream ref_file(reference_filepath_, std::ios::out);
        std::ofstream chan_file(changes_filepath_, std::ios::out);
        if (!ref_file.is_open() || !chan_file.is_open())
        {
            std::cerr << "Error: Unable to open metadata file " << eds_file_ << std::endl;
            return -3;
        }

        //  Data are validated for context length long enough
        std::string r_context, l_context; // keep context of length -1 (to search pattern of length 5 keep 4 characters of contexts)
        size_t cl_lessone = context_length_ - 1;

        std::vector<std::string> changes;
        std::vector<unsigned> start_positions_;
        size_t nchange = 0;

        bool context = 0; //  which context save 0=left,1=right
        bool change_open = false;

        chan_file << '#';

        size_t i = 0;
        char c;
        while (in.get(c))
        {
            // std::cout << c << std::endl;
            switch (c)
            {
            case '{':
                //  save position of starting degenerate symbol
                if (!base_position_.empty())
                {
                    base_position_.push_back(base_position_.back()+i);
                }else{
                    base_position_.push_back(i);
                }
                
                // base_position_.push_back((size_t)ref_file.tellp() - 1);

                n++;
                //  flush ref
                ref_file << l_context;

                if (!changes.empty()){
                    base_position_.back() += changes[0].size(); 
                    ref_file << changes[0];
                }

                //  flush changes
                start_positions_.push_back((size_t)chan_file.tellp() - 1);
                for (size_t k = 1; k < changes.size(); k++)
                {
                    if (l_context.size() > cl_lessone)
                        chan_file << l_context.substr(l_context.size() - cl_lessone, cl_lessone);
                    else
                        chan_file << l_context;

                    chan_file << changes[k];
                    chan_file << r_context.substr(0, cl_lessone);
                    chan_file << '#';
                    offset_.push_back(changes[k].size() - changes[0].size());
                }
                l_context = r_context;
                r_context.clear();
                changes.clear();
                changes.push_back("");
                ;

                //  setup open degenerate symbol
                nchange = 0;
                change_open = true;
                i = 0;
                break;
            case '}':
                context = context ^ 1;
                change_open = false;
                break;
            case ',':
                total_deg_strings++;
                changes.push_back("");
                nchange++;
                break;
            default:
                //  its character
                if (change_open)
                {
                    //  character belongs to string in degenerate set
                    changes[nchange].push_back(c);
                }
                else
                {
                    //  character belongs to common part
                    r_context.push_back(c);
                    i++;
                }
                break;
            }
        }

        N = i;
        //  flush ref
        ref_file << l_context;
        if (!changes.empty())
            ref_file << changes[0];
        ref_file << r_context;

        //  flush changes
        start_positions_.push_back((size_t)chan_file.tellp() - 1);
        for (size_t k = 1; k < changes.size(); k++)
        {
            if (l_context.size() >= cl_lessone)
                chan_file << l_context.substr(l_context.size() - cl_lessone, cl_lessone);
            else
                chan_file << l_context;

            chan_file << changes[k];
            if (r_context.size() > cl_lessone)
                chan_file << r_context.substr(r_context.size() - cl_lessone, cl_lessone);
            else
                chan_file << r_context;

            // chan_file << r_context.substr(0, cl_lessone);
            chan_file << '#';
            offset_.push_back(changes[k].size() - changes[0].size());
        }

        in.close();
        ref_file.close();
        chan_file.close();

        n = (n * 2) + 1;

        // base_position_.erase(base_position_.begin());

        std::ifstream file(changes_filepath_, std::ios::binary);
        //  create inary vectors
        file.seekg(0, file.end);
        size_t pos = file.tellg();
        file.seekg(0, file.beg);
        loc_ = sdsl::bit_vector(pos, 0);
        iloc_ = sdsl::bit_vector(pos, 0);
        i = 0;
        while (file.get(c))
        {
            if (c == '#')
                loc_[i] = 1;
            i++;
        }

        for (i = 0; i < start_positions_.size(); i++)
        {
            iloc_[start_positions_[i]] = 1;
        }
        iloc_[pos - 1] = 1;

        return 0;
    }

    int Bio_FMi::build()
    {

        try
        {
            std::cout << "(0/2) Parsing EDS";
            if (Bio_FMi::parse_eds())
            {
                std::cout << "Error: Uncomplete EDS parsing" << std::endl;
                return -1;
            }
            std::cout << " ... done" << std::endl;

            std::cout << "(1/3) Building fm-index over reference string";
            construct(reference_index_, reference_filepath_, 1);
            std::cout << " ... done" << std::endl;

            std::cout << "(2/3) Building fm-index over string of changes";
            construct(changes_index_, changes_filepath_, 1);
            std::cout << " ... done" << std::endl;

            std::cout << "(3/3) Building Rank and Select supports";
            riloc_ = rank_support_v<>(&iloc_);
            rloc_ = rank_support_v<>(&loc_);
            sloc_ = select_support_mcl<>(&loc_);
            std::cout << " ... done" << std::endl;

            total_index_size_ = size_in_mega_bytes(reference_index_) + size_in_mega_bytes(changes_index_) + size_in_mega_bytes(iloc_) + size_in_mega_bytes(loc_) + size_in_mega_bytes(base_position_) + size_in_mega_bytes(offset_) + size_in_mega_bytes(riloc_) + size_in_mega_bytes(rloc_) + size_in_mega_bytes(sloc_);

            save();
            return 0;
        }
        catch (const std::exception &e)
        {
            std::cerr << '\n'
                      << e.what() << '\n';
            return -2;
        }

        return 0;
    }

    void Bio_FMi::print_hash(const hash_type &hash_map)
    {
        for (const auto &pair : hash_map)
        {
            std::cout << "Key: (" << pair.first.first << ", " << pair.first.second << ")" << std::endl;
            std::cout << "Value: (" << pair.second.first << ", [ ";
            for (unsigned num : pair.second.second)
            {
                std::cout << num << " ";
            }
            std::cout << "])" << std::endl;
        }
    }

    void Bio_FMi::print_result(const hash_type &hash_map)
    {
        for (const auto &pair : hash_map)
        {
            std::cout << "Start position: " << pair.second.first << ", Used changes: [ ";
            for (unsigned num : pair.second.second)
            {
                std::cout << num << " ";
            }
            std::cout << "]" << std::endl;
        }
    }

    int Bio_FMi::locate(std::string P)
    {
        size_t chunk_index;
        size_t chunk_start_position;
        std::string chunk;
        unsigned block_number = 0;
        unsigned change_number = 0;
        int offset = 0;
        // size_t position;
        int pre_hash_loc;
        int pos_hash_loc;
        auto it = new_hash_map_.find({0, 0});
        bool next_outside_change = false;
        // bool next_in_change = false;

        /*  check pattern length and set the */
        //  if the pattern size is not divisible by the context_length split tha last two chunk into evenly parts
        if ((P.size() % context_length_) != 0)
        {
            std::cout << "Unsupported pattern length = needs to be product of context_length" << std::endl;
            return -1;
        }

        /*  for each chunk */
        for (chunk_index = 0; chunk_index < (P.size() / context_length_); chunk_index++)
        {
            chunk_start_position = chunk_index * context_length_;
            chunk = P.substr(chunk_start_position, context_length_);
            // std::cout << "Searching for a chunk number: " << chunk_index << " starting on position in pattern P:" << chunk_start_position << "=" << chunk << std::endl;

            /*  SEARCH in reference */
            auto ref_locations = sdsl::locate(reference_index_, chunk);
            // std::cout << "in I0: " << ref_locations.size() << std::endl;

            // /*  SEARCH in changes */
            auto change_locations = sdsl::locate(changes_index_, chunk);
            // std::cout << "in Id: " << change_locations.size() << std::endl;

            for (auto loc : ref_locations)
            {
                //  validate with saved locations
                // block_number = riloc_(loc);

                //  is the next position in the change? == is the rank number on loc+context_length increased by 1?
                // next_in_change = (block_number != riloc_(loc + context_length_));
                // std::cout << "next position in change: " << next_in_change << std::endl;

                // loc -= block_number;
                // std::cout << "chunk found on position: " << loc << std::endl;

                if (chunk_index == 0) //  first positions
                {
                    new_hash_map_[{loc + context_length_, -1}] = {loc, {}};
                }
                else
                {
                    //  VALIDATE

                    // case 1
                    it = old_hash_map_.find({loc, -1});
                    if (it != old_hash_map_.end())
                    {
                        // std::cout << "Case 1 found. Origin position " << it->second.first << std::endl;
                        new_hash_map_[{loc + context_length_, -1}] = it->second;
                    }

                    // case 4
                    it = old_hash_map_.find({loc, -2});
                    if (it != old_hash_map_.end())
                    {
                        // std::cout << "Case 4 found. Origin position " << it->second.first << std::endl;
                        new_hash_map_[{loc + context_length_, -1}] = it->second;
                    }
                }
            }

            for (auto loc : change_locations)
            {

                //  validate with saved locations
                //  it is location in change ( could be case 3 or 2)
                block_number = riloc_(loc) - 1;
                change_number = rloc_(loc) - 1;
                pre_hash_loc = sloc_(change_number + 1);
                pos_hash_loc = sloc_(change_number + 2);
                offset = loc - (pre_hash_loc + context_length_);

                //  will be the next position outside of change? Is actual change long enough to catch another chunk?
                next_outside_change = ((pos_hash_loc - context_length_ + 1) <= (loc + context_length_));
                // std::cout << "next position outside of change:" << next_outside_change << std::endl;

                loc = base_position_[block_number] + offset;
                // std::cout << "chunk found on position: " << base_position_[block_number] + offset << " while tracking change number " << change_number << std::endl;

                if (chunk_index == 0)
                {
                    //  first = just save all location into table
                    if (next_outside_change)
                    {
                        // std::cout << "Preparing for case 4, position:" << loc + context_length_ - offset_[change_number] << std::endl;
                        new_hash_map_[{loc + context_length_ - offset_[change_number], -2}] = {loc, {change_number}};
                    }
                    else
                    {
                        new_hash_map_[{loc + context_length_, change_number}] = {loc, {change_number}};
                    }
                }
                else
                {
                    //  VALIDATE
                    // std::cout << "Checking position" << loc - context_length_ << "in hash table" << std::endl;

                    //  case 2
                    it = old_hash_map_.find({loc, change_number});
                    if (it != old_hash_map_.end())
                    {
                        // std::cout << "Case 2 found. Origin position: " << it->second.first << std::endl;
                        if (next_outside_change)
                        {
                            // std::cout << "Preparing for case 4, position:" << loc + context_length_ - offset_[change_number] << std::endl;
                            new_hash_map_[{loc + context_length_ - offset_[change_number], -2}] = it->second;
                        }
                        else
                        {
                            new_hash_map_[{loc + context_length_, change_number}] = it->second;
                        }
                    }

                    //  case 3
                    it = old_hash_map_.find({loc, -1});
                    if (it != old_hash_map_.end())
                    {
                        auto cp = it->second;
                        // std::cout << "Case 3 found. Origin position: " << it->second.first << std::endl;
                        if (next_outside_change)
                        {
                            // std::cout << "Preparing for case 4, position:" << loc + context_length_ - offset_[change_number] << std::endl;
                            cp.second.push_back(change_number);
                            new_hash_map_[{loc + context_length_ - offset_[change_number], -2}] = cp;
                        }
                        else
                        {
                            cp.second.push_back(change_number);
                            new_hash_map_[{loc + context_length_, change_number}] = cp;
                        }
                    }

                    //  case 4
                    it = old_hash_map_.find({loc, -2});
                    if (it != old_hash_map_.end())
                    {
                        auto cp = it->second;
                        // std::cout << "Case 4 found. Origin position: " << it->second.first << std::endl;
                        if (next_outside_change)
                        {
                            // std::cout << "Preparing for case 4, position:" << loc + context_length_ - offset_[change_number] << std::endl;
                            cp.second.push_back(change_number);
                            new_hash_map_[{loc + context_length_ - offset_[change_number], -2}] = cp;
                        }
                        else
                        {
                            cp.second.push_back(change_number);
                            new_hash_map_[{loc + context_length_, change_number}] = cp;
                        }
                    }
                }
            }

            std::cout << std::endl;

            // print_hash(new_hash_map_);

            std::swap(old_hash_map_, new_hash_map_);
            new_hash_map_.clear();
        }

        // print_result(old_hash_map_);

        return 0;
    }

    int Bio_FMi::save()
    {
        try
        {
            // /*  save fm-indexes */
            store_to_file(reference_index_, index_bed_.replace_extension(".ri")); // save I0
            store_to_file(changes_index_, index_bed_.replace_extension(".ci"));   //    save Id
            // /*  save bit_vectors    */
            store_to_file(loc_, index_bed_.replace_extension(".loc"));   //  save bitvector loc
            store_to_file(iloc_, index_bed_.replace_extension(".iloc")); //  save bitvector iloc
            // /*  save context length*/
            store_to_file(base_position_, index_bed_.replace_extension(".abp"));
            store_to_file(offset_, index_bed_.replace_extension(".aof"));
        }
        catch (const std::exception &e)
        {
            std::cerr << e.what() << '\n';
            return -1;
        }
        return 0;
    }

    int Bio_FMi::load()
    {
        try
        {
            /*  load fm-indexes */
            load_from_file(reference_index_, index_bed_.replace_extension(".ri")); // load I0
            load_from_file(changes_index_, index_bed_.replace_extension(".ci"));   //    load Id
            /*  load bit_vectors    */
            load_from_file(loc_, index_bed_.replace_extension(".loc"));   //  load bitvector loc
            load_from_file(iloc_, index_bed_.replace_extension(".iloc")); //  load bitvector iloc
            /*  load context length*/
            load_from_file(base_position_, index_bed_.replace_extension(".abp")); //  load aBasepos vector
            load_from_file(offset_, index_bed_.replace_extension(".aof"));        //  load aOffset vector

            riloc_ = rank_support_v<>(&iloc_);
            rloc_ = rank_support_v<>(&loc_);
            sloc_ = select_support_mcl<>(&loc_);
        }
        catch (const std::exception &e)
        {
            std::cerr << e.what() << '\n';
            return -1;
        }
        return 0;
    }

    void Bio_FMi::print()
    {
        std::cout << "loc:                  " << loc_ << std::endl;
        std::cout << "iloc:                 " << iloc_ << std::endl;
        std::cout << "Context length: " << context_length_ << std::endl;
        std::cout << "Number of segments: " << n << std::endl;
        std::cout << "Number of changes: " << total_deg_strings << std::endl;
        std::cout << std::endl;

        std::cout << "aBasePos: ";
        for (auto &i : base_position_)
            std::cout << i << ", ";
        std::cout << std::endl;

        std::cout << "aOffset: ";
        for (auto &i : offset_)
            std::cout << i << ", ";
        std::cout << std::endl;
    }

    void Bio_FMi::print_stats()
    {
        std::cout << "Context length: " << context_length_ << std::endl;
        std::cout << "n: " << n << std::endl;
        std::cout << "N: " << N << std::endl;
        std::cout << "# denegenerated sets: " << total_deg_sets << std::endl;
        std::cout << "# strings in deg-sets: " << total_deg_strings << std::endl;
        std::cout << "Total index size: " << total_index_size_ << std::endl;
        std::cout << std::endl;
    }

    Bio_FMi::hash_type Bio_FMi::get_result()
    {
        return old_hash_map_;
    }
}
